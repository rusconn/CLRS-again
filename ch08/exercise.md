# 8 章 練習問題

## 8.1-1

スキップ

## 8.1-2

スキップ

## 8.1-3

スキップ

## 8.1-4

スキップ

## 8.2-1

> 配列 $A = \langle 6,0,2,0,1,3,4,6,1,3,2 \rangle$ 上での $\text{COUNTING-SORT}$ の振舞いを示せ。

A = [6 0 2 0 1 3 4 6 1 3 2]  
B = [X X X X X X X X X X X]  
C = [2 2 2 2 1 0 2]

A = [6 0 2 0 1 3 4 6 1 3 2]  
B = [X X X X X X X X X X X]  
C = [2 2 2 2 1 0 2]

A = [6 0 2 0 1 3 4 6 1 3 2]  
B = [X X X X X X X X X X X]  
C = [2 4 6 8 9 9 11]

A = [6 0 2 0 1 3 4 6 1 3 (2)]  
B = [X X X X X 2 X X X X X]  
C = [2 4 5 8 9 9 11]

A = [6 0 2 0 1 3 4 6 1 (3) 2]  
B = [X X X X X 2 X 3 X X X]  
C = [2 4 5 7 9 9 11]

A = [6 0 2 0 1 3 4 6 (1) 3 2]  
B = [X X X 1 X 2 X 3 X X X]  
C = [2 3 5 7 9 9 11]

A = [6 0 2 0 1 3 4 (6) 1 3 2]  
B = [X X X 1 X 2 X 3 X X 6]  
C = [2 3 5 7 9 9 10]

A = [6 0 2 0 1 3 (4) 6 1 3 2]  
B = [X X X 1 X 2 X 3 4 X 6]  
C = [2 3 5 7 8 9 10]

A = [6 0 2 0 1 (3) 4 6 1 3 2]  
B = [X X X 1 X 2 3 3 4 X 6]  
C = [2 3 5 6 8 9 10]

A = [6 0 2 0 (1) 3 4 6 1 3 2]  
B = [X X 1 1 X 2 3 3 4 X 6]  
C = [2 2 5 6 8 9 10]

A = [6 0 2 (0) 1 3 4 6 1 3 2]  
B = [X 0 1 1 X 2 3 3 4 X 6]  
C = [1 2 5 6 8 9 10]

A = [6 0 (2) 0 1 3 4 6 1 3 2]  
B = [X 0 1 1 2 2 3 3 4 X 6]  
C = [1 2 4 6 8 9 10]

A = [6 (0) 2 0 1 3 4 6 1 3 2]  
B = [0 0 1 1 2 2 3 3 4 X 6]  
C = [0 2 4 6 8 9 10]

A = [(6) 0 2 0 1 3 4 6 1 3 2]  
B = [0 0 1 1 2 2 3 3 4 6 6]  
C = [0 2 4 6 8 9 9]

## 8.2-2

> $\text{COUNTING-SORT}$ が安定であることを証明せよ。

$A$ の要素は右の要素から $B$ へ書き込まれる。  
同じ値の要素があった場合も $B$ の右から書き込まれる。  
方向が一致しているので安定。

## 8.2-3

> $\text{COUNTING-SORT}$ 手続きの第 $10$ 行目の**for 文**の頭部を
>
> ```pseudo
> for j = 1 to A.length
> ```
>
> に書き換える。アルゴリズムが依然として正しく動作することを示せ。修正したアルゴリズムは安定か？

$A$ の全要素が $B$ へ書き込まれることは変わらない。  
同じ値の要素があった場合の振舞いも変わらず左へ移動して書き込んでいくので正しく動作する。

安定性については、[練習問題 8.2-2](#82-2) より、方向が一致しなくなるので安定ではない。

## 8.2-4

> $0$ から $k$ の範囲にある $n$ 個の整数が入力として与えられている。入力を前処理し、任意の２整数 $a,b$ に対して $[a..b]$ の範囲にある入力された整数の個数を $O(1)$ 時間で答えるアルゴリズムを示せ。ただし、前処理にかかる時間は $\Theta(n + k)$ でなければならない。

$n$ 個の整数を $A$ とする。

計数ソートでやったように、 $C[i]$ に $A$ の $i$ 以下の要素数が入るような $C$ を用意する。この前処理は $\Theta(n + k)$ 。  
$A$ の $[a..b]$ の範囲にある要素の数は、 $0 < a < b \le k$ なら $C[b] - C[a-1]$ と表される。  
ただし、 入力値の関係により各種場合分けが必要。  
コードは [code.ts](./code.ts) に書いた。

## 8.3-1

> 以下の英単語のリストに対する $\text{RADIX-SORT}$ の振舞いを示せ。 $\text{COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAP, DIG, BIG, TEA, NOW, FOX}$ 。

| 最初 | 1 桁目 | 2 桁目 | 3 桁目 |
| ---- | ------ | ------ | ------ |
| COW  | SEA    | TAB    | BAR    |
| DOG  | TEA    | TAP    | BIG    |
| SEA  | MOB    | BAR    | BOX    |
| RUG  | TAB    | EAR    | COW    |
| ROW  | DOG    | SEA    | DIG    |
| MOB  | RUG    | TEA    | DOG    |
| BOX  | DIG    | DIG    | EAR    |
| TAB  | BIG    | BIG    | FOX    |
| BAR  | TAP    | MOB    | MOB    |
| EAR  | BAR    | DOG    | NOW    |
| TAP  | EAR    | COW    | ROW    |
| DIG  | COW    | ROW    | RUG    |
| BIG  | ROW    | NOW    | SEA    |
| TEA  | NOW    | BOX    | TAB    |
| NOW  | BOX    | FOX    | TAP    |
| FOX  | FOX    | RUG    | TEA    |

## 8.3-2

> 次のソーティングアルゴリズムのうち安定なものはどれか？挿入ソート、マージソート、ヒープソート、クイックソート。任意の比較ソートアルゴリズムを安定なものに修正するための簡単な方法を与えよ。この方法にはどの程度の余分な時間と領域が必要か？

挿入ソート、マージソートは安定そう。  
ヒープソートとクイックソートは安定じゃなさそう。

安定にするには前処理として各要素へ元々の位置情報を付加し、後処理として追加の情報を削除する。  
ソートする際には位置情報を第２のキーとする。  
時間も領域も $\Theta(n)$ 余分に必要？

## 8.3-3

> 基数ソートが正しく動作することを帰納法を用いて証明せよ。中間ソートが安定であるという仮定が必要となる証明の場所を示せ。

スキップ

## 8.3-4

> $0$ から $n^3 - 1$ の範囲にある $n$ 個の整数を $O(n)$ 時間でソートする方法を示せ。

スキップ

## 8.3-5 　 ★

> この節冒頭で紹介したカードをソートするアルゴリズムにおいて、 $d$ 桁の $10$ 進数をソートするために最悪の場合に必要なソートの回数を正確に求めよ。また、最悪の場合にオペレータが管理する必要のあるカードの山の個数を示せ。

スキップ

## 8.4-1

> 配列 $A = \langle .79,.13,.16,.64,.39,.20,.89,.53,.71,.42 \rangle$ 上での $\text{BUCKET-SORT}$ の振舞いを示せ。

A = [.79 .13 .16 .64 .39 .20 .89 .53 .71 .42]  
B = []

A = [.79 .13 .16 .64 .39 .20 .89 .53 .71 .42]  
B = [[] [.13 .16] [.20] [.39] [.42] [.53] [.64] [.79 .71] [.89] [] ]

A = [.79 .13 .16 .64 .39 .20 .89 .53 .71 .42]  
B = [[] [.13 .16] [.20] [.39] [.42] [.53] [.64] [.71 .79] [.89] [] ]

A = [.79 .13 .16 .64 .39 .20 .89 .53 .71 .42]  
B = [.13 .16 .20 .39 .42 .53 .64 .71 .79 .89]

## 8.4-2

> バケツソートの最悪実行時間が $\Theta(n^2)$ である理由を示せ。単純な修正をアルゴリズムに加えて、線形平均実行時間を保存しつつ最悪実行時間を $O(n\lg n)$ に改良できるか？

１つのバケツに全要素が挿入された場合、そのバケツの挿入ソートにかかる実行時間が $\Theta(n^2)$ となるため。  
バケツのソートに使うアルゴリズムをマージソートへ変更すれば最悪実行時間を $O(n\lg n)$ に改良できる。  
ヒープソートでもいいけど多分安定じゃなくなるよね。

## 8.4-3

> 公正なコインを２回フリップした時に表の出る回数を表す確率変数を $X$ とする。 $E[X^2]$ を求めよ。また、 $E^2[X]$ はいくらか？

$E[X] = 2 \times 1/4 + 1 \times 1/2 + 0 \times 1/4 = 1 $  
$E[X^2] = 4 \times 1/4 + 1 \times 1/2 + 0 \times 1/4 = 3/2 $  
$E^2[X] = E[X] \times E[X] = 1 $

## 8.4-4 ★

スキップ

## 8.4-5 ★

スキップ
