# 12 章 練習問題

## 12.1-1

> キーの集合 $\lbrace 1,4,5,10,16,17,21 \rbrace$ を格納する高さ $2,3,4,5,6$ の $2$ 分探索木を描け。

### 高さ $2$

![高さ2の図](../diagram/12.1-1-a.png)

### 高さ $3$

![高さ3の図](../diagram/12.1-1-b.png)

### 高さ $4$

![高さ4の図](../diagram/12.1-1-c.png)

### 高さ $5$

![高さ5の図](../diagram/12.1-1-d.png)

### 高さ $6$

![高さ6の図](../diagram/12.1-1-e.png)

## 12.1-2

> $2$ 分探索木条件と $min$ ヒープ条件（第 $6.1$ 節を参照）の違いを述べよ。 $min$ ヒープ条件を利用して、 $n$ 個の節点を持つ木に格納されているキーをソートされた順で $O(n)$ 時間で印刷することができるか？できると思うときにはその方法を、できないと思うときにはなぜできないかを説明せよ。

$2$ 分探索木条件は左右の関係、 $min$ ヒープ条件は上下の関係。  
ソート順での印刷に関してはできない。次の要素がどこにあるかがわからないので、巡回する道が重複してしまう。

## 12.1-3

> 中間順木巡回を実現する非再帰的なアルゴリズムを記述せよ。（**ヒント:** スタックを補助データ構造として用いる簡単な解がある。より複雑であるが洗練された解では、スタックを用いず、その代わりに $2$ つのポインタの等価性判定が可能であると仮定する。）

```pseudo
INORDER-TREE-WALK(x):
  S を スタックとする
  V を 配列とする
  PUSH(S, x)
  if not EMPTY(S)
    x = POP(S)
    if x == NIL
      continue
    if V が x を含む
      x.key を印刷する
      continue
    V に x を追加する
    PUSH(S, x.right)
    PUSH(S, x)
    PUSH(S, x.left)
```

## 12.1-4

> $n$ 個の節点を持つ木を $\Theta(n)$ 時間で先行順及び後行順で巡回する再帰的アルゴリズムを設計せよ。

```pseudo
PREORDER-TREE-WALK(x):
  if x ≠ NIL
    x.key を印刷する
    PREORDER-TREE-WALK(x.left)
    PREORDER-TREE-WALK(x.right)
```

```pseudo
POSTORDER-TREE-WALK(x):
  if x ≠ NIL
    POSTORDER-TREE-WALK(x.left)
    POSTORDER-TREE-WALK(x.right)
    x.key を印刷する
```

## 12.1-5

> 比較演算モデルでは $n$ 個の要素をソートするのに最悪の場合には $\Omega(n\lg n)$ 時間かかることから、比較演算だけを用いて $n$ 個の要素を持つ任意のリストから $2$ 分探索木を構成するどのアルゴリズムも、最悪の場合には実行に $\Omega(n\lg n)$ 時間かかることを説明せよ。

？
