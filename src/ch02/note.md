# 2 章 さあ、始めよう

## 2.1 挿入ソート

挿入ソートは少数の要素を効率よくソートするアルゴリズム。  
トランプで手札をソートするときに多くの人が使う方法。

まず左手を空にし、テーブルの上にカードを裏向きに置く。  
次に、テーブルから１枚ずつカードを取って、左手の正しい位置に挿入してゆく。  
カードの正しい位置は、右から左へと順に既に手の中にあるカードと比較すれば発見できる。

```pseudo
INSERTION-SORT(A):
  for j = 2 to A.length
    key = A[j]
    A[j]をソート済みの列A[1..j-1]に挿入する
    i = j - 1
    while i > 0 かつ A[i] > key
      A[i + 1] = A[i]
      i = i - 1
    A[i + 1] = key
```

### ループ不変式と挿入ソートの正当性

アルゴリズムの正当性を示すために**ループ不変式**(loop invariant)を導入する。

`INSERTION-SORT` のループ不変式:

<i>**for 文**の各ループ実行開始時、 $\textit{A[1..j-1]}$ には開始時点で $\textit{A[1..j-1]}$ に格納されていた要素がソートされた状態で格納されている。</i>

ループ不変式に対して３つの性質を示す必要がある。

- **初期条件**: 初回実行開始時にループ不変式は真である

- **ループ内条件**: 何回目かの実行開始時にループ不変式が真ならば、次の実行開始時でも真である

- **終了条件**: ループが停止したとき、アルゴリズムの正当性の証明に繋がる有力な性質が不変式から得られる

最初の２つの性質が成立すれば、すべてのループの実行開始時にループ不変式は真となる。  
ループを抜けた際にもループ不変式が成立するので、そこからアルゴリズムの正当性を示す。

挿入ソートについて、これらの性質が成立していることを確かめる。

- **初期条件**: $j=2$ の時、 $A[1..j-1]$ は唯一の要素 $A[1]$ から構成され、  
  これは元々 $A[1]$ に格納されていた要素である。ソート済みであるとみなせる。

- **ループ内条件**: **for 文** の本体が行なっているのは、 $A[j]$ を入れるべき場所が見つかるまで  
  $A[j-1],A[j-2],A[j-3],...$ をそれぞれ 1 つ右に移し空いた場所に $A[j]$ の値を挿入することである。  
  $A[1..j]$ は元々 $A[1..j]$ に格納されていた要素から構成されているが、既にソートされている。  
  **for**文の次の繰返しのために $j$ に $1$ を加えるとループ不変式が維持される

- **終了条件**: **for 文** 停止時に $j = n + 1$ が成立する。ループ不変式の $j$ に $n + 1$ を代入すると、  
  「 $A[1..n]$ には開始時点で $A[1..n]$ に格納されていた要素がソートされた状態で格納されている。」となる。  
  $A[1..n]$ が配列全体であることに注意すると、配列全体がソート済みであると結論できる

ループ不変式を用いてアルゴリズムの正当性を示すこの方法を他の章でも用いる。

## 2.2 アルゴリズムの解析

アルゴリズムの実行に必要な資源量を予測することを、アルゴリズムを解析する（analyzing）と言う。  
多くの場合、予測したいのは計算時間。

### 最悪時と平均時の解析

実行時間は入力によって変わり得る。  
**サイズ** $n$ の**任意の**入力に対する最長の実行時間である、**最悪実行時間**(worst-case running time)を考えることが多い。

アルゴリズムの**平均**(average-case)実行時間を検討することもある。  
本書を通して、**確率的解析**(probabilistic analysis)を様々なアルゴリズムに対して適用する。

### 増加のオーダ

実行時間の**増加率**(rate of growth)または**増加のオーダ**(order of growth)を解析する際、式の主要項(高次項)だけを考える。  
主要項の係数や低次の項は $n$ が大きいとき相対的に重要度が低いから省略する。

挿入ソートの最悪実行時間は大雑把に $an^2 + bn + c$ と記述できるが、上記ルールを適用すると $n^2$ と抽象化される。  
これを、挿入ソートは $\Theta(n^2)$ の最悪実行時間を持つと書く。 $\Theta$ 記法は第３章で定義する。

あるアルゴリズムが他のアルゴリズムよりその最悪実行時間の増加率が低い場合、効率が良いと考える。

## 2.3 アルゴリズムの設計

挿入ソートは**逐次添加法**(incremental approach)を用いている。  
本節では「分割統治法」として知られている設計方針について検討する。  
分割統治法アルゴリズムは通常、第４章で説明する方法を用いて実行時間を容易に決定できる。

### 2.3.1 分割統治法(divide-and-conquer)

多くの有用なアルゴリズムの構造は**再帰的**(recursive)である。  
分割統治法では問題を元の問題と類似してはいるがサイズが小さいいくつかの部分問題に分解し、  
これらの部分問題を再帰的に解いた後、その解を組み合わせて元の問題に対する解を構成する。

分割統治パラダイムの再帰の各レベルは以下の３つの段階から構成される。

- **分割:** 問題をいくつかの同じ問題のより小さいインスタンスである部分問題に分解する
- **統治:** 部分問題を再帰的に解くことによって統治する。ただし、部分問題のサイズが十分小さい場合は直接的な方法で解く
- **結合:** 部分問題の解を組み合わせて元の問題の解を得る

**マージソート**(merge sort)アルゴリズムは分割統治パラダイムに厳密に従って構成されている。  
各段階は直観的には以下のように記述できる。

- **分割:** ソートすべき長さ $n$ の列を２つの長さ $n/2$ の部分列に分解する
- **統治:** マージソートを用いて２つの部分列を再帰的にソートする
- **結合:** ２つのソートされた部分列をマージしてソートされた解を作る

再帰が"底をつく"のはソートすべき列の長さが１になったときである。  
長さ１の列は既にソートされているから、何もすることはない。

```pseudo
MERGE-SORT(A, p, r):
  if p < r
    q = ⌊(p + r) / 2⌋
    MERGE-SORT(A, p, q)
    MERGE-SORT(A, q + 1, r)
    MERGE(A, p, q, r)
```

```pseudo
MERGE(A, p, q, r):
  n₁ = q - p + 1
  n₂ = r - q
  L[1..n₁+1] と R[1..n₂+1] を2つの新しい配列とする
  for i = 1 to n₁
    L[i] = A[p + i - 1]
  for j = 1 to n₂
    R[j] = A[q + j]
  L[n₁ + 1] = ∞
  R[n₂ + 1] = ∞
  i = 1
  j = 1
  for k = p to r
    if L[i] <= R[j]
      A[k] = L[i]
      i = i + 1
    else
      A[k] = R[j]
      j = j + 1
```

手続き`MERGE`の実行時間は $\Theta(n)$。詳細な算出は省略する。  
では手続き`MERGE-SORT`の実行時間は？

### 2.3.2 分割統治アルゴリズムの解析

アルゴリズムが再帰的である場合、実行時間を**漸化式**(recurrence)の形で表現できることが多い。

サイズ $n$ の問題に対する実行時間を $T(n)$ とする。  
問題サイズが十分に小さい場合、直接的な方法で問題を解くので定数時間しかかからない。これを $\Theta(1)$ と書く。  
問題が $a$ 個の部分問題に分割され、各部分問題のサイズは元の問題の $1/b$ である場合、  
$a$ 個の部分問題をすべて解くのに $aT(n/b)$ 時間かかる。  
問題を部分問題に分割するのに $D(n)$ 時間かかり、部分問題の解を結合するのに $C(n)$ 時間かかるとすると、漸化式

$$
  T(n) = \begin{cases}
    \Theta(1) & n \text{ is small } \\
    aT(n/b) + D(n) + C(n) & \text{otherwise}
  \end{cases}
$$

を得る。このような形式の漸化式を解く一般的な方法を第４章で学ぶ。

### マージソートの解析

解析の簡単の為、`MERGE-SORT`の問題サイズが２のベキ乗であると仮定する。  
$n(>1)$ 個の要素に対する実行時間を以下のように分解する。

- **分割:** 部分列の中央を計算するだけであり、定数時間で済む。したがって、 $D(n) = \Theta(1)$ である
- **統治:** 再帰的にサイズ $n/2$ の部分問題を２つ解く。したがって、 $2T(n/2)$ 時間が必要となる
- **結合:** `MERGE`手続きの実行時間が $\Theta(n)$ だから、 $C(n) = \Theta(n)$ である

これにより、マージソートの最悪実行時間 $T(n)$ に対する漸化式

$$
  T(n) = \begin{cases}
    \Theta(1) & n = 1 \\
    2T(n/2) + \Theta(n) & n > 1
  \end{cases}
$$

を得る。第４章で証明する「マスター定理」を用いると、 $T(n)$ が $\Theta(n\lg n)$ であることが証明できる。  
$\lg n$ は $\log_2 n$ の略記である。

[← 前へ](../ch01/note.md)

[次へ →](../ch03/note.md)
