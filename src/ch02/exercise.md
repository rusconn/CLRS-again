# 2 章 練習問題

## 2.1-1

> 配列 $A = \langle 31,41,59,26,41,58 \rangle$ 上での`INSERTION-SORT`の動作を説明せよ

初期状態: 〈**31**,41₁,59,26,41₂,58〉  
j = 2 開始:〈**31**,_41₁_,59,26,41₂,58〉  
j = 2 終了:〈**31,41₁**,59,26,41₂,58〉  
j = 3 開始:〈**31,41₁**,_59_,26,41₂,58〉  
j = 3 終了:〈**31,41₁,59**,26,41₂,58〉  
j = 4 開始:〈**31,41₁,59**,_26_,41₂,58〉  
j = 4 終了:〈**26,31,41₁,59**,41₂,58〉  
j = 5 開始:〈**26,31,41₁,59**,_41₂_,58〉  
j = 5 終了:〈**26,31,41₁,41₂,59**,58〉  
j = 6 開始:〈**26,31,41₁,41₂,59**,_58_〉  
j = 6 終了:〈**26,31,41₁,41₂,58,59**〉

## 2.1-2

> `INSERTION-SORT`手続きは非減少順でソートする。これを書き換えて非増加順でソートするようにせよ。

$A[i] > key$ を $A[i] < key$ に変更する。

## 2.1-3

> 以下の**探索問題**(searching problem)を考えよう。
>
> **入力:** 長さ $n$ の数列 $A = \langle a_1,a_2,...,a_n \rangle$ とある値 $v$  
> **出力:** $v = A[i]$ となる添字 $i$、または $v$ が $A$ の中に存在しないときは特別な値 $NIL$
>
> **順次探索**（linear search）の擬似コードを書け。順次探索は $v$ を探しながら列を走査するアルゴリズムである。ループ不変式を用いて、このアルゴリズムの正当性を証明せよ。このループ不変式が必要とされる３つの性質を満たすことを確認せよ。

```pseudo
LINEAR-SEARCH(A, v):
  for i = 1 to A.length
    if A[i] == v
      return i
  return NIL
```

ループ不変式:

<i>**for 文**の各ループ実行開始時、 $\textit{A[1..i-1]}$ は既に探索済みであり、 $v$ を含まない。</i>

- **初期条件**: $i=1$ の時、 $A[1..i-1]$ は存在しないので、探索済みと考えることができ、もちろん $v$ を含まない

- **ループ内条件**: **for 文**の本体が行なっているのは、 $A[1],A[2],...$ を順に探索し、 $v$ が見つかったらその時点の $i$ を返すことである。  
  $v$ が見つかるとループが終わってしまうので、 $v$ が見つからない場合のみ考える。  
  ある $i$ についてループ不変式が成立すると仮定する。 $v$ が見つからないので次のループへ進む。  
  このときループ不変式は $A[1..i]$ が探索済みで $v$ を含まないとなる。  
  実際に $A[i]$ が探索され、かつ $v$ が見つからなかったので、 $A[1..i]$ は探索済みであり、 $v$ を含まない

- **終了条件**: **for 文**の停止時に $i = n + 1$ が成立する。  
  ループ不変式の $i$ に $n + 1$ を代入すると、「 $A[1..n]$ は既に探索済みであり、 $v$ を含まない」となる。  
   $A[1..n]$ が配列全体であることに注意すると、配列全体が探索済みであり、 $v$ を含まないと結論できる

## 2.1-4

> ２つの $n$ 要素配列 $A$ と $B$ に蓄えられた２つの $n$ ビットの２進数の和を求める問題を考える。この２つの整数の和は２進数として( $n+1$ )要素配列 $C$ に蓄える。この問題を形式的に記述し、２つの整数の和を求める擬似コードで記せ。

```pseudo
ADD-BINARY(A, B):
  C を n+1 要素の配列とする
  carry = 0
  for i = A.length to 1
    sum = carry + A[i] + B[i]
    carry = div(sum, 2)
    C[i + 1] = remainder(sum, 2)
  C[0] = carry
  return C
```

## 2.2-1

> 関数 $n^3/1000 - 100n^2 - 100n + 3$ を $\Theta$ 記法を用いて表現せよ。

$\Theta(n^3)$

## 2.2-2

> 配列 $A$ に蓄えられた $n$ 個の数を次の方法でソートすることを考えよう。まず、 $A$ の中の最小要素を見つけてそれを $A[1]$ と交換する。次に、 $A$ の２番目に小さい要素を見つけてそれを $A[2]$ と交換する。これを $A$ の $n-1$ 個の要素について繰り返す。**選択ソート**(selection sort)として知られるこのアルゴリズムの擬似コードを書け。このアルゴリズムではどんなループ不変式が維持されているだろうか？ $n$ 個の要素全てについて実行する必要はなく、最初の $n-1$ 個だけでよいのはなぜか？この選択ソートの最良時と最悪時の実行時間を $\Theta$ 記法で表現せよ。

```pseudo
SELECTION-SORT(A):
  for i = 1 to A.length - 1
    min = i
    for j = i + 1 to A.length
      if min > A[j]
        min = j
    swap(A, i, min)
```

ループ不変式:

<i>**外側の for 文**の各ループ実行開始時、 $\textit{A[1..i-1]}$ はソート済みであり、 $\textit{A[i..A.length]}$ よりも小さい要素で構成される。</i>

最初の $n-1$ 個だけでよいのは、 $n$ 個目は最後の要素であり、最大の要素だから。

最良実行時間: $\Theta(n^2)$  
最悪実行時間: $\Theta(n^2)$

## 2.2-3

> 再び順次探索法（[練習問題 2.1-3](#21-3)を参照）について考えよう。探索すべき要素が配列中の任意の要素と等確率で一致すると仮定した上で、入力列の中で調べられる要素数の平均を求めよ。最悪の場合はどうか？順次探索法の平均時と最悪時の実行時間を $\Theta$ 記法を用いて示せ。答が正しいことを説明せよ。

平均要素数: $n/2$  
最悪要素数: $n$

平均実行時間: $\Theta(n)$  
最悪実行時間: $\Theta(n)$

## 2.2-4

> おおよそすべてのアルゴリズムに対して適用可能な、もっと良い最良実行時間を持つようにアルゴリズムを改良する方法を述べよ。

いくつかの入力について予めアルゴリズムを実行して結果を保存しておく。  
実際の入力に対する実行結果が保存されている場合には直ちにその保存内容を出力する。

## 2.3-1

> 配列 $A = \langle 3,41,52,26,38,57,9,49 \rangle$ 上のマージソートの動作を図示せよ。

↑〈3,9,25,38,41,49,52,57〉  
↑〈3,25,41,52〉〈9,38,49,57〉  
↑〈3,41〉〈26,52〉〈38,57〉〈9,49〉  
↑〈3〉〈41〉〈52〉〈26〉〈38〉〈57〉〈9〉〈49〉

## 2.3-2

> 手続き`MERGE`を番兵を使わないように書き直せ。代わりに、 $L$ か $R$ のどちらかですべての要素が $A$ に書き戻されたら直ちに停止し、他方に残されている要素を $A$ に書き戻すようにせよ。

```pseudo
MERGE-WITHOUT-SENTINEL(A, p, q, r):
  n₁ = q - p + 1
  n₂ = r - q
  L[1..n₁] と R[1..n₂] を2つの新しい配列とする
  for i = 1 to n₁
    L[i] = A[p + i - 1]
  for j = 1 to n₂
    R[j] = A[q + j]
  i = 1
  j = 1
  for k = p to r
    if i > n₁
      A[k] = R[j]
      j = j + 1
    elseif j > n₂
      A[k] = L[i]
      i = i + 1
    elseif L[i] <= R[j]
      A[k] = L[i]
      i = i + 1
    else
      A[k] = R[j]
      j = j + 1
```

## 2.3-3

> $n$ が２のベキ乗のとき、漸化式
>
> $$
>   T(n) = \begin{cases}
>     2 & n = 2 \\
>     2T(\frac{n}{2}) + n & k > 1 \text{ に対して } n = 2^k
>   \end{cases}
> $$
>
> の解が $T(n) = n\lg n$ であることを数学的帰納法を用いて示せ。

$n = 2$ のとき、 $n\lg n = 2\lg 2 = 2 \times 1 = 2$ となり成立。

$n = 2^k (k\ge 1)$ のとき $T(2^k) = 2^k\lg 2^k$ が成り立つ場合、 $T(2^{k+1}) = 2^{k+1}\lg 2^{k+1}$ も成り立つことを示す。

$$
  \begin{split}
    T(2^{k+1}) &= 2T(\frac{2^{k+1}}{2}) + 2^{k+1} \\
               &= 2T(2^k) + 2^{k+1} \\
               &= 2 \times 2^k\lg 2^k + 2^{k+1} \\
               &= 2^{k+1}\lg 2^k + 2^{k+1} \\
               &= 2^{k+1}(\lg 2^k + 1) \\
               &= 2^{k+1}\lg 2^{k+1}
  \end{split}
$$

## 2.3-4

> 挿入ソートは再帰的手続きとしても表現できる。 $A[1..n]$ をソートするには再帰的に $A[1..n-1]$ をソートし、次に $A[n]$ をソート済みの配列 $A[1..n-1]$ に挿入すればよい。再帰版の挿入ソートの最悪実行時間に対する漸化式を書け。

$$
  T(n) = \begin{cases}
    \Theta(1) & n = 1 \\
    T(n-1) + \Theta(n) & n > 1
  \end{cases}
$$

## 2.3-5

> 探索問題（[練習問題 2.1-3](#21-3)を参照）に戻って、列 $A$ がソートされていれば、この列の中央値を $v$ と比較することで列の半分を以降の探索範囲から除去できる。**２分探索**(binary search)はこの手続きを繰り返し、繰返しのたびに残された列の長さを半減する。２分探索（繰返し型と再帰型のどちらでもよい）の擬似コードを書け。２分探索の最悪実行時間が $\Theta(\lg n)$ であることを示せ。

```pseudo
BINARY-SEARCH-ITERATIVE(A, v, i, j):
  while i <= j
    mid = ⌊(i + j) / 2⌋
    if v < A[mid]
      j = mid - 1
    elseif A[mid] < v
      i = mid + 1
    else
      return mid
  return NIL
```

```pseudo
BINARY-SEARCH-RECURSIVE(A, v, i, j):
  if i > j
    return NIL
  mid = ⌊(i + j) / 2⌋
  if v < A[mid]
    return BINARY-SEARCH-RECURSIVE(A, v, i, mid - 1)
  elseif A[mid] < v
    return BINARY-SEARCH-RECURSIVE(A, v, mid + 1, j)
  else
    return mid
```

分割は中央の位置を算出するだけなので定数時間。結合は無いのでノーコスト。  
部分問題はサイズが半分になるので、アルゴリズムの実行時間は対数的になる。  
よって最悪実行時間は $\Theta(\lg n)$ となる。

## 2.3-6

> 2.1 節で示した`INSERTION-SORT`手続きの**while**文では、ソート済み部分配列 $A[i..j-1]$ の（逆向き）走査に順次探索を用いた。順次探索の代わりに２分探索（[練習問題 2.3-5](#23-5)を参照）を用いて挿入ソートの最悪実行時間を $\Theta(n\lg n)$ に改善できるか？

できない。挿入場所の探索だけならば $\Theta(\lg n)$ でできるようになるが、  
ソート済要素の移動をする必要があるので、**while**文の実行時間は $\Theta(n)$ のままとなる。  
よって、挿入ソートの最悪実行時間は $\Theta(n^2)$ にとどまる。

## 2.3-7 ★

> $n$ 個の整数の集合 $S$ とある整数 $x$ が与えられたとき、 $S$ の中の２個の要素で、それらの和がちょうど $x$ になるものが存在するかどうかを決定する $\Theta(n\lg n)$ 時間アルゴリズムを記述せよ。

```pseudo
HAS-COUPLE(S, x):
  MERGE-SORT(S, 1, S.length)
  for i = 1 to S.length - 1
    if BINARY-SEARCH(S, x - S[i], i + 1, S.length) != NIL
      return true
  return false
```
