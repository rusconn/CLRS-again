# 2 章 練習問題

## 2.1-1

> 配列 $A = \langle 31,41,59,26,41,58 \rangle$ 上での`INSERTION-SORT`の動作を説明せよ

初期状態: 〈**31**,41₁,59,26,41₂,58〉  
j = 2 開始:〈**31**,_41₁_,59,26,41₂,58〉  
j = 2 終了:〈**31,41₁**,59,26,41₂,58〉  
j = 3 開始:〈**31,41₁**,_59_,26,41₂,58〉  
j = 3 終了:〈**31,41₁,59**,26,41₂,58〉  
j = 4 開始:〈**31,41₁,59**,_26_,41₂,58〉  
j = 4 終了:〈**26,31,41₁,59**,41₂,58〉  
j = 5 開始:〈**26,31,41₁,59**,_41₂_,58〉  
j = 5 終了:〈**26,31,41₁,41₂,59**,58〉  
j = 6 開始:〈**26,31,41₁,41₂,59**,_58_〉  
j = 6 終了:〈**26,31,41₁,41₂,58,59**〉

## 2.1-2

> `INSERTION-SORT`手続きは非減少順でソートする。これを書き換えて非増加順でソートするようにせよ。

$A[i] > key$ を $A[i] < key$ に変更する。

## 2.1-3

> 以下の**探索問題**(searching problem)を考えよう。
>
> **入力:** 長さ $n$ の数列 $A = \langle a_1,a_2,...,a_n \rangle$ とある値 $v$  
> **出力:** $v = A[i]$ となる添字 $i$、または $v$ が $A$ の中に存在しないときは特別な値 $NIL$
>
> **順次探索**（linear search）の擬似コードを書け。順次探索は $v$ を探しながら列を走査するアルゴリズムである。ループ不変式を用いて、このアルゴリズムの正当性を証明せよ。このループ不変式が必要とされる３つの性質を満たすことを確認せよ。

```pseudo
LINEAR-SEARCH(A, v):
  for i = 1 to A.length
    if A[i] == v
      return i
  return NIL
```

ループ不変式:

<i>**for 文**の各ループ実行開始時、 $\textit{A[1..i-1]}$ は既に探索済みであり、 $v$ を含まない。</i>

- **初期条件**: $i=1$ の時、 $A[1..i-1]$ は存在しないので、探索済みと考えることができ、もちろん $v$ を含まない

- **ループ内条件**: **for 文**の本体が行なっているのは、 $A[1],A[2],...$ を順に探索し、 $v$ が見つかったらその時点の $i$ を返すことである。  
  $v$ が見つかるとループが終わってしまうので、 $v$ が見つからない場合のみ考える。  
  ある $i$ についてループ不変式が成立すると仮定する。 $v$ が見つからないので次のループへ進む。  
  このときループ不変式は $A[1..i]$ が探索済みで $v$ を含まないとなる。  
  実際に $A[i]$ が探索され、かつ $v$ が見つからなかったので、 $A[1..i]$ は探索済みであり、 $v$ を含まない

- **終了条件**: **for 文**の停止時に $i = n + 1$ が成立する。  
  ループ不変式の $i$ に $n + 1$ を代入すると、「 $A[1..n]$ は既に探索済みであり、 $v$ を含まない」となる。  
   $A[1..n]$ が配列全体であることに注意すると、配列全体が探索済みであり、 $v$ を含まないと結論できる

## 2.1-4

> ２つの $n$ 要素配列 $A$ と $B$ に蓄えられた２つの $n$ ビットの２進数の和を求める問題を考える。この２つの整数の和は２進数として( $n+1$ )要素配列 $C$ に蓄える。この問題を形式的に記述し、２つの整数の和を求める擬似コードで記せ。

```pseudo
ADD-BINARY(A, B):
  C を n+1 要素の配列とする
  carry = 0
  for i = A.length to 1
    sum = carry + A[i] + B[i]
    carry = div(sum, 2)
    C[i + 1] = remainder(sum, 2)
  C[0] = carry
  return C
```

## 2.2-1

> 関数 $n^3/1000 - 100n^2 - 100n + 3$ を $\Theta$ 記法を用いて表現せよ。

$\Theta(n^3)$

## 2.2-2

> 配列 $A$ に蓄えられた $n$ 個の数を次の方法でソートすることを考えよう。まず、 $A$ の中の最小要素を見つけてそれを $A[1]$ と交換する。次に、 $A$ の２番目に小さい要素を見つけてそれを $A[2]$ と交換する。これを $A$ の $n-1$ 個の要素について繰り返す。**選択ソート**(selection sort)として知られるこのアルゴリズムの擬似コードを書け。このアルゴリズムではどんなループ不変式が維持されているだろうか？ $n$ 個の要素全てについて実行する必要はなく、最初の $n-1$ 個だけでよいのはなぜか？この選択ソートの最良時と最悪時の実行時間を $\Theta$ 記法で表現せよ。

```pseudo
SELECTION-SORT(A):
  for i = 1 to A.length - 1
    min = i
    for j = i + 1 to A.length
      if min > A[j]
        min = j
    swap(A, i, min)
```

ループ不変式:

<i>**外側の for 文**の各ループ実行開始時、 $\textit{A[1..i-1]}$ はソート済みであり、 $\textit{A[i..A.length]}$ よりも小さい要素で構成される。</i>

最初の $n-1$ 個だけでよいのは、 $n$ 個目は最後の要素であり、最大の要素だから。

最良実行時間: $\Theta(n^2)$  
最悪実行時間: $\Theta(n^2)$

## 2.2-3

> 再び順次探索法（[練習問題 2.1-3](#21-3)を参照）について考えよう。探索すべき要素が配列中の任意の要素と等確率で一致すると仮定した上で、入力列の中で調べられる要素数の平均を求めよ。最悪の場合はどうか？順次探索法の平均時と最悪時の実行時間を $\Theta$ 記法を用いて示せ。答が正しいことを説明せよ。

平均要素数: $n/2$  
最悪要素数: $n$

平均実行時間: $\Theta(n)$  
最悪実行時間: $\Theta(n)$

## 2.2-4

> おおよそすべてのアルゴリズムに対して適用可能な、もっと良い最良実行時間を持つようにアルゴリズムを改良する方法を述べよ。

いくつかの入力について予めアルゴリズムを実行して結果を保存しておく。  
実際の入力に対する実行結果が保存されている場合には直ちにその保存内容を出力する。
