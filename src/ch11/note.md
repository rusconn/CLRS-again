# 11 章 ハッシュ表

ハッシュ表は普通の配列の概念の一般化。  
辞書を効率よく実現するデータ構造。  
要素の探索に最悪 $\Theta(n)$ かかるが、妥当な仮定の下では平均 $O(1)$ 。

## 11.1 直接アドレス表

出現する可能性のあるキーの全集合 $U = \lbrace 0,1,\ldots m-1 \rbrace$ がそれほど大きくない場合に有効。  
**直接アドレス表**(direct-address table)と呼ぶ配列 $T$ を用いる。  
配列の各位置を**枠**(slot)と呼ぶ。枠は全集合 $U$ のキーに対応する。

```pseudo
DIRECT-ADDRESS-SEARCH(T, k):
  return T[k]
```

```pseudo
DIRECT-ADDRESS-INSERT(T, x):
  T[x.key] = x
```

```pseudo
DIRECT-ADDRESS-DELETE(T, x):
  T[x.key] = NIL
```

どれも $O(1)$ 時間で走る。  
枠 $k$ が集合内のキー $k$ を持つ要素を指している。 $k$ は重複しないと仮定した。  
集合がキー $k$ を持つ要素を含まなければ $T[k] = \text{NIL}$ である。

この方法には２つの欠点がある

- 全集合 $U$ が非常に大きいときには、記憶領域が足りなくなる
- **実際に格納される**キーの集合が $U$ に比べて小さいとき、記憶領域が無駄になる

（計数ソートに似ているな？）

## 11.2 ハッシュ表

直接アドレス表の欠点を克服するため、ハッシュ表を用いる。  
ハッシュ表を用いると、要素の探索が $O(1)$ であるという特徴を維持したまま、必要な領域を削減できる。  
ただし、直接アドレス法の探索時間は**最悪評価**なのに対し、ハッシュ表の探索時間は**平均時間**。

ハッシュ法ではキー $k$ を持つ要素を枠 $k$ へではなく、 $h(k)$ へ格納する。  
$h$ はキー $k$ から枠を計算するための**ハッシュ関数**(hash function)。
$h$ はキーの全集合 $U$ から**ハッシュ表**(hash table) $T[0..m-1]$ の枠の集合への写像、すなわち

$$
  h: U \rightarrow \lbrace 0,1,\ldots,m-1 \rbrace
$$

であり、普通、ハッシュ表のサイズ $m$ は $U$ のサイズに比べて十分に小さい。  
キー $k$ を持つ要素を枠 $h(k)$ にハッシュ(hash)すると言い、 $h(k)$ をキー $k$ の**ハッシュ値**(hash value)と呼ぶ。  
ハッシュ関数は配列添字の値域を狭め、配列サイズを減少させる。

このアイデアは、同じ枠に複数のキーがハッシュされる可能性があるという欠点を抱えている。  
この状況を**衝突**(collision)と言う。  
衝突を解決するための方法を用意しておく必要がある。  
衝突解決方式として、本節ではチェイン法、第 $11.4$ 節ではオープンアドレス指定法を紹介する。

### チェイン法による衝突解決

**チェイン法**(chaining)では同じ枠にハッシュされたすべての要素を１つの連結リストに置く。  
枠 $j$ に格納するのは $j$ にハッシュされたすべての要素を格納するリストの先頭を指すポインタとする。

```pseudo
CHAINED-HASH-INSERT(T, x):
  x をリスト T[h(x.key)] の先頭に挿入する
```

```pseudo
CHAINED-HASH-SEARCH(T, k):
  リスト T[h(k)] の中からキー k を持つ要素を探索する
```

```pseudo
CHAINED-HASH-DELETE(T, x):
  リスト T[h(x.key)] から x を削除する
```

挿入の最悪実行時間は $O(1)$ である。  
挿入においてキーの重複を考慮するなら、キー x.key を持つ要素を検索する必要があるのでこの限りではない。  
また、双方向連結リストを用いると要素の削除操作を $O(1)$ で実現できる。

### チェイン法を用いるハッシュ法の解析

挿入と削除は $O(1)$ 時間で実行できるとわかるが、探索にかかる時間が不明なので解析する。  
$n$ 個の要素を格納している枠数 $m$ のハッシュ表 $T$ の**負荷率**(load factor) $α$ を $n/m$ で定義する。  
$α$ は１つのチェインに格納されている要素数の平均を意味する。

ハッシュ関数が**単純一様ハッシュ**(simple uniform hashing)（他の要素がどの枠にハッシュされたかとは無関係に、 $m$ 個の枠へ等確率でハッシュする）であると仮定すると、  
要素の探索にかかる時間はハッシュ算出の $O(1)$ 、チェイン探索の $\Theta(\alpha)$ の和である、 $\Theta(1 + \alpha)$ となる。  
枠数が少なくとも要素数に比例すると仮定すると $n = O(m)$ であり、 $\alpha = n/m = O(m)/m = O(1)$ を結論できる。  
つまり、挿入、探索、削除をすべて平均 $O(1)$ 時間で提供できる。

[← 前へ](../ch10/note.md)
