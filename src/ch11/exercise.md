# 11 章 練習問題

## 11.1-1

> サイズが $m$ の直接アドレス表 $T$ によって表現された動的集合 $S$ を考える。 $S$ の最大要素を発見する手続きを記述せよ。この手続きの最悪実行時の性能を評価せよ。

最悪実行時間: $\Theta(m)$

```pseudo
MAXIMUM(S):
  if m == 0
    return NIL
  else
    max = DIRECT-ADDRESS-SEARCH(S, 0)
    for i = 1 to m-1
      x = DIRECT-ADDRESS-SEARCH(S, i)
      if x > max
        max = x
    return max
```

## 11.1-2

> **ビットベクトル**(bit vector)は単にビット（ $0$ と $1$ ）の配列である。長さ $m$ のビットベクトルは $m$ 個のポインタの配列に比べ領域が少なくて済む。付属データを持たない相異なる要素からなる動的集合をビットベクトルを使って表現する方法を述べよ。ただし、辞書操作は $O(1)$ 時間で実行できなくてはならない。

```pseudo
BIT-VECTOR-SEARCH(V, k):
  if V[k] == 0
    return NIL
  else
    return k
```

```pseudo
BIT-VECTOR-INSERT(V, k):
  V[k] = 1
```

```pseudo
BIT-VECTOR-DELETE(V, k):
  V[k] = 0
```

## 11.1-3

> 格納される要素のキーが必ずしも異なるとは限らず、しかも付属データが存在する可能性があるとき、直接アドレス法を実現する方法を述べよ。ただし、３つの辞書操作（ $\text{INSERT}$, $\text{DELETE}$, $\text{SEARCH}$ ）はすべて $O(1)$ 時間で実行できなくてはならない。（ $\text{DELETE}$ は、 $key$ ではなく削除されるオブジェクトを指すポインタを引数として取ることに注意せよ。）

？

## 11.1-4 ★

> **巨大な**配列上の直接アドレス指定法を用いて辞書を実現したい。初期化前の配列には塵データが格納されているが、サイズが巨大だから配列全体を初期化するのは非現実的である。巨大な配列上で直接アドレス法を実現する方法を示せ。ただし、各オブジェクトの格納には $O(1)$ 領域を用い、操作 $\text{SEARCH}$, $\text{INSERT}$, $\text{DELETE}$ は $O(1)$ で走り、データ構造の初期化は $O(1)$ 時間で完了する必要がある。（**ヒント:** 与えられた巨大配列の要素の正当性判定を助けるために、辞書に実際に格納されているキー数をサイズとするスタック風に扱われる補助配列を用いよ。）

？
