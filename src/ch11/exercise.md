# 11 章 練習問題

## 11.1-1

> サイズが $m$ の直接アドレス表 $T$ によって表現された動的集合 $S$ を考える。 $S$ の最大要素を発見する手続きを記述せよ。この手続きの最悪実行時の性能を評価せよ。

最悪実行時間: $\Theta(m)$

```pseudo
MAXIMUM(S):
  if m == 0
    return NIL
  else
    max = DIRECT-ADDRESS-SEARCH(S, 0)
    for i = 1 to m-1
      x = DIRECT-ADDRESS-SEARCH(S, i)
      if x > max
        max = x
    return max
```

## 11.1-2

> **ビットベクトル**(bit vector)は単にビット（ $0$ と $1$ ）の配列である。長さ $m$ のビットベクトルは $m$ 個のポインタの配列に比べ領域が少なくて済む。付属データを持たない相異なる要素からなる動的集合をビットベクトルを使って表現する方法を述べよ。ただし、辞書操作は $O(1)$ 時間で実行できなくてはならない。

```pseudo
BIT-VECTOR-SEARCH(V, k):
  if V[k] == 0
    return NIL
  else
    return k
```

```pseudo
BIT-VECTOR-INSERT(V, k):
  V[k] = 1
```

```pseudo
BIT-VECTOR-DELETE(V, k):
  V[k] = 0
```

## 11.1-3

> 格納される要素のキーが必ずしも異なるとは限らず、しかも付属データが存在する可能性があるとき、直接アドレス法を実現する方法を述べよ。ただし、３つの辞書操作（ $\text{INSERT}$, $\text{DELETE}$, $\text{SEARCH}$ ）はすべて $O(1)$ 時間で実行できなくてはならない。（ $\text{DELETE}$ は、 $key$ ではなく削除されるオブジェクトを指すポインタを引数として取ることに注意せよ。）

？

## 11.1-4 ★

> **巨大な**配列上の直接アドレス指定法を用いて辞書を実現したい。初期化前の配列には塵データが格納されているが、サイズが巨大だから配列全体を初期化するのは非現実的である。巨大な配列上で直接アドレス法を実現する方法を示せ。ただし、各オブジェクトの格納には $O(1)$ 領域を用い、操作 $\text{SEARCH}$, $\text{INSERT}$, $\text{DELETE}$ は $O(1)$ で走り、データ構造の初期化は $O(1)$ 時間で完了する必要がある。（**ヒント:** 与えられた巨大配列の要素の正当性判定を助けるために、辞書に実際に格納されているキー数をサイズとするスタック風に扱われる補助配列を用いよ。）

？

## 11.2-1

> $n$ 個の相異なるキーを長さ $m$ の配列 $T$ にハッシュ関数 $h$ を用いてハッシュするとする。単純一様ハッシュを仮定するとき、衝突回数の期待値を求めよ。より正確に言うと、集合 $\lbrace \lbrace k,l \rbrace : k \ne l \text{ かつ } h(k) = h(l) \rbrace$ のサイズの期待値を求めよ。

？

## 11.2-2

> チェイン法を用いて衝突を解決するハッシュ表にキー $5,28,19,15,20,33,12,17,10$ が挿入されていく様子を示せ。ただし、表は $9$ 個の枠を持ち、ハッシュ関数は $h(k) = k \bmod 9$ であるとせよ。

| 挿入する要素 | ハッシュ表                                                                                                                                                |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 5            | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL                                                                                                               |
| 28           | NIL, NIL, NIL, NIL, NIL, $\langle 5 \rangle$, NIL, NIL, NIL                                                                                               |
| 19           | NIL, $\langle 28 \rangle$, NIL, NIL, NIL, $\langle 5 \rangle$, NIL, NIL, NIL                                                                              |
| 15           | NIL, $\langle 19,28 \rangle$, NIL, NIL, NIL, $\langle 5 \rangle$, NIL, NIL, NIL                                                                           |
| 20           | NIL, $\langle 19,28 \rangle$, NIL, NIL, NIL, $\langle 5 \rangle$, $\langle 15 \rangle$, NIL, NIL                                                          |
| 33           | NIL, $\langle 19,28 \rangle$, $\langle 20 \rangle$, NIL, NIL, $\langle 5 \rangle$, $\langle 15 \rangle$, NIL, NIL                                         |
| 12           | NIL, $\langle 19,28 \rangle$, $\langle 20 \rangle$, NIL, NIL, $\langle 5 \rangle$, $\langle 33,15 \rangle$, NIL, NIL                                      |
| 17           | NIL, $\langle 19,28 \rangle$, $\langle 20 \rangle$, $\langle 12 \rangle$, NIL, $\langle 5 \rangle$, $\langle 33,15 \rangle$, NIL, NIL                     |
| 10           | NIL, $\langle 19,28 \rangle$, $\langle 20 \rangle$, $\langle 12 \rangle$, NIL, $\langle 5 \rangle$, $\langle 33,15 \rangle$, NIL, $\langle 17 \rangle$    |
| -            | NIL, $\langle 10,19,28 \rangle$, $\langle 20 \rangle$, $\langle 12 \rangle$, NIL, $\langle 5 \rangle$, $\langle 33,15 \rangle$, NIL, $\langle 17 \rangle$ |

## 11.2-3

> チェイン方式を修正し、各リストをソート済みリストとして管理することで性能が改善できると宍戸教授は考えた。教授のこの変更が成功する探索、失敗に終わる探索、挿入、削除に対して与える影響を検討せよ。

成功する探索: 影響なし  
失敗に終わる探索: 定数係数の範囲で速くなる  
挿入: 適切な位置に挿入する必要があるので定数係数の範囲で遅くなる
削除: 影響なし

## 11.2-4

> 未使用枠を未使用リストに連結することによって、ハッシュ表の中で要素を格納するための記憶領域を割り付けたり回収したりする方法を示唆せよ。ただし、１つの枠に格納できるのは、１つのフラッグに加え、１つの要素と１つのポインタか２つのポインタのどちらかであると仮定する。辞書操作及び未使用リスト操作はすべて $O(1)$ 時間で走らなければならない。未使用リストは双方向でなければならないか、あるいは一方向で十分か？

スキップ

## 11.2-5

> サイズが $m$ のハッシュ表に $n$ 個のキーを格納したい。キーの普遍集合 $U$ が $|U| > nm$ を満たすとき、同じ枠にハッシュされるサイズ $n$ のキー集合が存在し、したがって、チェイン法を用いるハッシュ法では最悪探索時間が $\Theta(n)$ になることを示せ。

スキップ

## 11.2-6

> チェイン法で衝突を解決するサイズが $m$ のハッシュ表に $n$ 個のキーが格納されており、最長のチェインの長さ $L$ を含めて、各チェインの長さが既知であるとする。ハッシュ表に格納されているキーの中から期待時間 $O(L \cdot (1 + 1/\alpha))$ で１つのキーを一様ランダムに選択する手続きを記述せよ。

スキップ

## 11.3-1

> 長さ $n$ の連結リストを探索したい。ただし、各要素にはハッシュ値 $h(k)$ がキー $k$ と共に含まれている。各キーは長い文字列である。ある与えられたキーを持つ要素をリストの中から発見するために、ハッシュ値をどのように用いればよいか？

まずハッシュ値を比較し、一致する場合のみキーを比較する。  
キーは長い文字列なので比較が遅い可能性があるが、ハッシュ値の比較は速いかもしれない。

## 11.3-2

> $r$ 文字から構成される文字列を基数 $128$ の数と解釈し、除算法を用いて $m$ 個の枠を持つ表にハッシュする。数 $m$ は容易に $32$ ビット長の $1$ 語で表現できるが、 $r$ 文字から構成される文字列を基数 $128$ の数として扱うには多くの語が必要になる。除算法を適用して、文字列の格納に必要な語を除き定数個の語を用いて、文字列のハッシュ値を計算する方法を示せ。

文字列を $s$ とする。  
Horner 法と剰余演算を組み合わせる。

```pseudo
HASH(s, m):
  sum = 0
  for i = 1 to r
    sum = (ASCII-CODE(s[i]) + 128 * sum) % m
  return sum
```

## 11.3-3

> ハッシュ関数が $h(k) = k \bmod m$ によって定義される除算法において、 $m = 2^p - 1$ で $k$ が 基数 $2^p$ によって解釈される文字列の場合を考える。文字列 $x$ が文字列 $y$ から文字の置換によって導かれるならば、 $x$ と $y$ は同じ値にハッシュされることを示せ。この性質がハッシュ関数として好ましくない応用例を示せ。

？

## 11.3-4

> サイズ $m = 1000$ のハッシュ表とそこで使用するハッシュ関数 $h(k) = \lfloor m(kA \bmod 1) \rfloor$ を考える。ここで、 $A = (\sqrt{5} - 1)/2$ である。キー $61,62,63,64,65$ がハッシュされる場所を計算せよ。

```javascript
const m = 1000;
const A = (Math.sqrt(5) - 1) / 2;
const h = k => Math.floor(m * ((k * A) % 1));
[61, 62, 63, 64, 65].map(h); // [ 700, 318, 936, 554, 172 ]
```

## 11.3-5 ★

スキップ

## 11.3-6 ★

スキップ

## 11.4-1

> 補助ハッシュ関数 $h'(k) = k$ を用いるオープンアドレス指定法によって、大きさ $m = 11$ のハッシュ表にキー $10,22,31,4,15,28,17,88,59$ を挿入する。線形探査法、 $c_1=1,c_2=3$ とした $2$ 次関数探査法、 $h_1(k) = k$ と $h_2(k) = 1+(k \bmod (m-1))$ を用いるダブルハッシュ法を利用したときの挿入結果を図示せよ。

### 線形探査法

$h(k, i) = k + i$

| 挿入する要素 | ハッシュ表                                            |
| ------------ | ----------------------------------------------------- |
| 10           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL |
| 22           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10  |
| 31           | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10   |
| 4            | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 31, 10    |
| 15           | 22, NIL, NIL, NIL, 4, NIL, NIL, NIL, NIL, 31, 10      |
| 28           | 22, NIL, NIL, NIL, 4, 15, NIL, NIL, NIL, 31, 10       |
| 17           | 22, NIL, NIL, NIL, 4, 15, 28, NIL, NIL, 31, 10        |
| 88           | 22, NIL, NIL, NIL, 4, 15, 28, 17, NIL, 31, 10         |
| 59           | 22, 88, NIL, NIL, 4, 15, 28, 17, NIL, 31, 10          |
| -            | 22, 88, NIL, NIL, 4, 15, 28, 17, 59, 31, 10           |

### $2$ 次関数探査法

$h(k, i) = k + i + 3i^2$

| 挿入する要素 | ハッシュ表                                            |
| ------------ | ----------------------------------------------------- |
| 10           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL |
| 22           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10  |
| 31           | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10   |
| 4            | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 31, 10    |
| 15           | 22, NIL, NIL, NIL, 4, NIL, NIL, NIL, NIL, 31, 10      |
| 28           | 22, NIL, NIL, NIL, 4, NIL, NIL, NIL, 15, 31, 10       |
| 17           | 22, NIL, NIL, NIL, 4, NIL, 28, NIL, 15, 31, 10        |
| 88           | 22, NIL, NIL, 17, 4, NIL, 28, NIL, 15, 31, 10         |
| 59           | 22, NIL, 88, 17, 4, NIL, 28, NIL, 15, 31, 10          |
| -            | 22, NIL, 88, 17, 4, NIL, 28, 59, 15, 31, 10           |

### ダブルハッシュ法

$h(k, i) = (k + i(1 + k \bmod 10)) \bmod 11$

| 挿入する要素 | ハッシュ表                                            |
| ------------ | ----------------------------------------------------- |
| 10           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL |
| 22           | NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10  |
| 31           | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 10   |
| 4            | 22, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, 31, 10    |
| 15           | 22, NIL, NIL, NIL, 4, NIL, NIL, NIL, NIL, 31, 10      |
| 28           | 22, NIL, NIL, NIL, 4, 15, NIL, NIL, NIL, 31, 10       |
| 17           | 22, NIL, NIL, NIL, 4, 15, 28, NIL, NIL, 31, 10        |
| 88           | 22, NIL, NIL, 17, 4, 15, 28, NIL, NIL, 31, 10         |
| 59           | 22, NIL, NIL, 17, 4, 15, 28, 88, NIL, 31, 10          |
| -            | 22, NIL, 59, 17, 4, 15, 28, 88, NIL, 31, 10           |

## 11.4-2

> 本文で概略を説明した $\text{HASH-DELETE}$ の擬似コードを書き、 $\text{HASH-INSERT}$ を特別な値 $\text{DELETED}$ が扱えるように修正せよ。

```pseudo
HASH-DELETE(T, k):
  i = 0
  repeat
    j = h(k, i)
    if T[j] == k
      T[j] = DELETED
      return j
    else
      i = i + 1
  until T[j] == NIL または i == m
  error "not exist"
```

```pseudo
HASH-INSERT'(T, k):
  i = 0
  repeat
    j = h(k, i)
    if T[j] == NIL または T[j] == DELETED
      T[j] = k
      return j
    else
      i = i + 1
  until i == m
  error "ハッシュ表オーバーフロー"
```

## 11.4-3

> 一様ハッシュを仮定するオープンアドレス指定法を考える。負荷率が $3/4$ と $7/8$ のときに、失敗に終わる探索に必要な探査回数の期待値の上界と、成功する探索に必要な探査回数の期待値の上界を求めよ。

### 負荷率 $3/4$

失敗: $1/(1-\alpha) = 1/(1-3/4) = 4$  
成功: $\frac{1}{\alpha}\ln\frac{1}{1-\alpha} = \frac{1}{3/4}\ln\frac{1}{1-3/4} = 4/3 \ln 4 \approx 1.848 $

### 負荷率 $7/8$

失敗: $1/(1-\alpha) = 1/(1-7/8) = 8$  
成功: $\frac{1}{\alpha}\ln\frac{1}{1-\alpha}\frac{1}{7/8}\ln\frac{1}{1-7/8} = 8/7\ln 8 \approx 2.376$

## 11.4-4 ★

スキップ

## 11.4-5 ★

スキップ
